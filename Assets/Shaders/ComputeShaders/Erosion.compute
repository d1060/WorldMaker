// Erosion Compute Shader
// Original code by Sebastian Lague

// https://www.youtube.com/watch?v=9RHGLZLUuwc
// https://github.com/SebLague/Hydraulic-Erosion

#pragma kernel CSMain

RWStructuredBuffer<float> map;

StructuredBuffer<float2> randomUVs;
StructuredBuffer<int> brushIndices;
StructuredBuffer<float> brushWeights;

int mapWidth;
int brushLength;

int maxLifetime;
float inertia;
float sedimentCapacityFactor;
float minSedimentCapacity; // Should be very small.
float depositSpeed;
float erodeSpeed;

float evaporateSpeed;
float gravity;
float startSpeed;
float startWater;
//float waterLevel;

void wrapCoordinates(inout uint2 coordinates)
{
    if (coordinates.x >= (uint)mapWidth * 4) coordinates.x -= mapWidth * 4;
    if (coordinates.y >= (uint)mapWidth * 2) coordinates.y = mapWidth * 4 - coordinates.y;
}

void wrapFloatCoordinates(inout float2 coordinates)
{
    if (coordinates.x < 0) coordinates.x += mapWidth * 4;
    if (coordinates.x >= mapWidth * 4) coordinates.x -= mapWidth * 4;
    if (coordinates.y < 0) coordinates.y = -coordinates.y;
    if (coordinates.y >= mapWidth * 2) coordinates.y = mapWidth * 4 - coordinates.y;
}

void CalculateHeightAndGradient(float2 coordinates, inout float2 gradient, inout float height)
{
    uint2 coord = uint2((uint)coordinates.x, (uint)coordinates.y);

    float u = coordinates.x - coord.x;
    float v = coordinates.y - coord.y;

    uint2 coordR = uint2(coord.x + 1, coord.y);
    wrapCoordinates(coordR);
    uint2 coordT = uint2(coord.x, coord.y + 1);
    wrapCoordinates(coordT);
    uint2 coordTR = uint2(coord.x + 1, coord.y + 1);
    wrapCoordinates(coordTR);

    int index = coord.x + coord.y * mapWidth * 4;
    int indexR = coordR.x + coordR.y * mapWidth * 4;
    int indexT = coordT.x + coordT.y * mapWidth * 4;
    int indexTR = coordTR.x + coordTR.y * mapWidth * 4;

    float heightDL = map[index];
    float heightDR = map[indexR];
    float heightUL = map[indexT];
    float heightUR = map[indexTR];

    height = (1 - v) * ((1 - u) * heightDL + u * heightDR) + v * ((1 - u) * heightUL + u * heightUR);
    gradient = float2((1 - v) * (heightDR - heightDL) + v * (heightUR - heightUL),
                      (1 - u) * (heightUL - heightDL) + u * (heightUR - heightDR));
}

[numthreads(64, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float2 uv = randomUVs[id.x];
    uint x = uv.x * mapWidth * 4;
    uint y = uv.y * mapWidth * 2;

    if (x >= (uint)mapWidth * 4 || y >= (uint)mapWidth * 2)
        return;

    float2 coordinates = float2(uv.x * mapWidth * 4, uv.y * mapWidth * 2);

    float dirX = 0;
    float dirY = 0;
    float speed = startSpeed;
    float water = startWater;
    float sediment = 0;
    //int isUnderwater = false;

    for (int lifetime = 0; lifetime < maxLifetime; lifetime++)
    {
        int nodeX = (int)(coordinates.x);
        int nodeY = (int)(coordinates.y);
        int prevIndex = nodeX + nodeY * mapWidth * 4;

        // Calculate droplet's offset inside the cell (0,0) = at NW node, (1,1) = at SE node
        float cellOffsetX = coordinates.x - nodeX;
        float cellOffsetY = coordinates.y - nodeY;

        // Calculate droplet's height and direction of flow with bilinear interpolation of surrounding heights
        float height;
        float2 gradient;
        CalculateHeightAndGradient(coordinates, gradient, height);

        //if (height < waterLevel)
        //    isUnderwater = true;

        // Update the droplet's direction and position (move position 1 unit regardless of speed)
        dirX = (dirX * inertia - gradient.x * (1 - inertia));
        dirY = (dirY * inertia - gradient.y * (1 - inertia));

        // Normalize direction
        float len = max(0.0001, sqrt(dirX * dirX + dirY * dirY));
        dirX /= len;
        dirY /= len;

        float2 newCoordinates = float2(coordinates.x + dirX, coordinates.y + dirY);
        if (newCoordinates.x < 0) newCoordinates.x += mapWidth * 4;
        if (newCoordinates.x >= mapWidth * 4) newCoordinates.x -= mapWidth * 4;
        if (newCoordinates.y < 0) newCoordinates.y = -newCoordinates.y;
        if (newCoordinates.y >= mapWidth * 2) newCoordinates.y = mapWidth * 4 - newCoordinates.y;

        coordinates = newCoordinates;

        // Find the droplet's new height and calculate the deltaHeight
        float newHeight;
        float2 newGradient;
        CalculateHeightAndGradient(coordinates, newGradient, newHeight);
        float deltaHeight = newHeight - height;

        // Calculate the droplet's sediment capacity (higher when moving fast down a slope and contains lots of water)
        float sedimentCapacity = max(-deltaHeight * speed * water * sedimentCapacityFactor, minSedimentCapacity);

        // If carrying more sediment than capacity, or if flowing uphill:
        if (sediment > sedimentCapacity || deltaHeight > 0)
        {
            // If moving uphill (deltaHeight > 0) try fill up to the current height, otherwise deposit a fraction of the excess sediment
            float amountToDeposit = 0;
            if (deltaHeight > 0)
            {
                amountToDeposit = min(deltaHeight, (sediment - sedimentCapacity)) * depositSpeed;
            }
            else
            {
                amountToDeposit = min(-deltaHeight, (sediment - sedimentCapacity)) * depositSpeed;
            }

            //if (height < waterLevel && height + amountToDeposit > waterLevel)
            //    amountToDeposit = waterLevel - height;

            sediment -= amountToDeposit;

            // Add the sediment to the four nodes of the previous cell using bilinear interpolation
            // Deposition is not distributed over a radius (like erosion) so that it can fill small pits
            uint2 coord = uint2(nodeX, nodeY);
            uint2 coordR = uint2(coord.x + 1, coord.y);
            wrapCoordinates(coordR);
            uint2 coordT = uint2(coord.x, coord.y + 1);
            wrapCoordinates(coordT);
            uint2 coordTR = uint2(coord.x + 1, coord.y + 1);
            wrapCoordinates(coordTR);

            int index = coord.x + coord.y * mapWidth * 4;
            int indexR = coordR.x + coordR.y * mapWidth * 4;
            int indexT = coordT.x + coordT.y * mapWidth * 4;
            int indexTR = coordTR.x + coordTR.y * mapWidth * 4;

            map[index] += amountToDeposit * (1 - cellOffsetX) * (1 - cellOffsetY);
            map[indexR] += amountToDeposit * (1 - cellOffsetX) * cellOffsetY;
            map[indexT] += amountToDeposit * cellOffsetX * (1 - cellOffsetY);
            map[indexTR] += amountToDeposit * cellOffsetX * cellOffsetY;
        }
        else
        {
            // Erode a fraction of the droplet's current carry capacity.
            // Clamp the erosion to the change in height so that it doesn't dig a hole in the terrain behind the droplet
            float amountToErode = min((sedimentCapacity - sediment) * erodeSpeed, -deltaHeight);

            for (int i = 0; i < brushLength; i ++)
            {
                int brushX = brushIndices[i * 2];
                int brushY = brushIndices[i * 2 + 1];

                float2 erodeCoordinates = float2(coordinates.x + brushX, coordinates.y + brushY);
                wrapFloatCoordinates(erodeCoordinates);
                int index = (int)erodeCoordinates.x + (int)erodeCoordinates.y * mapWidth * 4;

                //shiftGradient(coordinates, erodeCoordinates, dirX, dirY);

                float weightedErodeAmount = amountToErode * brushWeights[i];
                float mapValue = map[index];
                float deltaSediment = (mapValue < weightedErodeAmount) ? mapValue : weightedErodeAmount;
                map[index] += -deltaSediment;
                sediment += deltaSediment;
            }
        }

        // Update droplet's speed and water content
        speed = sqrt(max(0, speed * speed + deltaHeight * gravity));
        water *= (1 - evaporateSpeed);
    }
}
