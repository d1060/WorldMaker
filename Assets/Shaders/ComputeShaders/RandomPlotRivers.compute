// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RiverAlphas
#pragma kernel ConsolidateTexture

int mapWidth;
int maxRiverLength;
float flowMapMaxValue;
float3 riverColor;
float riverExponent;
float lowerLimit;
float higherLimit;

StructuredBuffer<int> riverFlowMask;
StructuredBuffer<uint> connectivityMap;
StructuredBuffer<uint> flowMap;

RWStructuredBuffer<float> riverAlphas;
RWTexture2D<float4> result;

[numthreads(32,32,1)]
void RiverAlphas (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)mapWidth * 4 || id.y >= (uint)mapWidth * 2)
        return;

    uint index = id.x + id.y * mapWidth * 4;
    if (riverFlowMask[index] != 1)
        return;

    uint connectivity = index;
    for (int i = 0; i < maxRiverLength; i++)
    {
        uint newIndex = connectivityMap[connectivity];
        if (newIndex == 0)
            return;

        connectivity = newIndex;

        float flow = (float)flowMap[newIndex] / flowMapMaxValue;

        flow = pow(abs(flow), riverExponent);

        float alpha = 1;
        if (flow < lowerLimit)
            alpha = 0;
        else if (flow < higherLimit)
            alpha = (flow - lowerLimit) / (higherLimit - lowerLimit);

        if (alpha > 0)
        {
            float originalAlpha;
            //riverAlphas[newIndex] = alpha;
            InterlockedExchange(riverAlphas[newIndex], alpha, originalAlpha);
        }
    }
}

[numthreads(32, 32, 1)]
void ConsolidateTexture(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x + id.y * mapWidth * 4;
    float alpha = riverAlphas[index];
    if (alpha <= 0)
        return;

    float4 color = float4(riverColor.r, riverColor.g, riverColor.b, alpha);
    result[id.xy] = color;
}