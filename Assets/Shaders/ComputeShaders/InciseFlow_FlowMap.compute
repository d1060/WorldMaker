#pragma kernel CSMain

int mapWidth;
float flowAmount = 1;
float maxFlow = 1000;
int numPasses = 100;

StructuredBuffer<int> connectivityMap;
RWStructuredBuffer<uint> flowMap; // The Flow Map contains a number indicating how much water is flowing into each pixel.

#include "Assets/Shaders/Cubemap.cginc"

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)mapWidth * 4 || id.y >= (uint)mapWidth * 2)
        return;

    int index = id.x + id.y * mapWidth * 4;

    //int3 cubemapLeft = getLeftIntCoordinates(cubemap, mapWidth);
    //int3 cubemapRight = getRightIntCoordinates(cubemap, mapWidth);
    //int3 cubemapTop = getTopIntCoordinates(cubemap, mapWidth);
    //int3 cubemapBottom = getBottomIntCoordinates(cubemap, mapWidth);

    //int3 cubemapTopLeft = getTopLeftIntCoordinates(cubemap, mapWidth);
    //int3 cubemapBottomRight = getBottomRightIntCoordinates(cubemap, mapWidth);
    //int3 cubemapTopRight = getTopRightIntCoordinates(cubemap, mapWidth);
    //int3 cubemapBottomLeft = getBottomLeftIntCoordinates(cubemap, mapWidth);

    int connectivity = connectivityMap[index];

    if (connectivity == 0)
        return;

    for (int i = 0; i < numPasses; i++)
    {
        int newIndex = connectivityMap[connectivity];

        flowMap[newIndex] += flowAmount > 0.000001 ? flowAmount : 0.000001;

        connectivity = newIndex;

        if (connectivity == 0)
            return;
    }

    //uint indexL = cubemapLeft.x + cubemapLeft.z * mapWidth + cubemapLeft.y * mapWidth * 6;
    //uint indexR = cubemapRight.x + cubemapRight.z * mapWidth + cubemapRight.y * mapWidth * 6;
    //uint indexT = cubemapTop.x + cubemapTop.z * mapWidth + cubemapTop.y * mapWidth * 6;
    //uint indexB = cubemapBottom.x + cubemapBottom.z * mapWidth + cubemapBottom.y * mapWidth * 6;
    //uint indexBL = cubemapBottomLeft.x + cubemapBottomLeft.z * mapWidth + cubemapBottomLeft.y * mapWidth * 6;
    //uint indexBR = cubemapBottomRight.x + cubemapBottomRight.z * mapWidth + cubemapBottomRight.y * mapWidth * 6;
    //uint indexTL = cubemapTopLeft.x + cubemapTopLeft.z * mapWidth + cubemapTopLeft.y * mapWidth * 6;
    //uint indexTR = cubemapTopRight.x + cubemapTopRight.z * mapWidth + cubemapTopRight.y * mapWidth * 6;

    // Flow Map.
    //float inflowAmount = flowAmount >= 0 ? flowAmount : 0.000001;

    //inflowAmount += getFlowFrom(index, cubemapLeft);
    //if (inflowAmount > maxFlow) inflowAmount = maxFlow;
    //inflowAmount += getFlowFrom(index, cubemapRight);
    //if (inflowAmount > maxFlow) inflowAmount = maxFlow;
    //inflowAmount += getFlowFrom(index, cubemapTop);
    //if (inflowAmount > maxFlow) inflowAmount = maxFlow;
    //inflowAmount += getFlowFrom(index, cubemapBottom);
    //if (inflowAmount > maxFlow) inflowAmount = maxFlow;
    //inflowAmount += getFlowFrom(index, cubemapBottomLeft);
    //if (inflowAmount > maxFlow) inflowAmount = maxFlow;
    //inflowAmount += getFlowFrom(index, cubemapBottomRight);
    //if (inflowAmount > maxFlow) inflowAmount = maxFlow;
    //inflowAmount += getFlowFrom(index, cubemapTopLeft);
    //if (inflowAmount > maxFlow) inflowAmount = maxFlow;
    //inflowAmount += getFlowFrom(index, cubemapTopRight);
    //if (inflowAmount > maxFlow) inflowAmount = maxFlow;

    //setFlowAt(cubemap, inflowAmount);
}
