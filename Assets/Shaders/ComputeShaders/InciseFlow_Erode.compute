// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

int mapWidth;
float exponent = 2;
float heightFactor = 0.05;
float strength = 1;
float minAmount = 0;
float curveFactor = 1;
float heightInfluence = 1;
float waterLevel = 0.6;
float blur = 0;
float flowMapMaxValue = 1000000;
StructuredBuffer<float> heightMap12;
StructuredBuffer<float> heightMap34;
StructuredBuffer<float> heightMap56;
StructuredBuffer<float> flowMap12;
StructuredBuffer<float> flowMap34;
StructuredBuffer<float> flowMap56;

RWStructuredBuffer<float> inciseFlowErosionMap12;
RWStructuredBuffer<float> inciseFlowErosionMap34;
RWStructuredBuffer<float> inciseFlowErosionMap56;

#include "Assets/Shaders/Cubemap.cginc"

#define MIN_WATER_HEIGHT 0.0045

void setErosionFlowMapValueAtCoordinates(uint3 coordinates, float value)
{
    uint index = coordinates.x + coordinates.y * mapWidth;

    if (coordinates.z == 1 || coordinates.z == 3 || coordinates.z == 5)
        index += mapWidth * mapWidth;

    if (coordinates.z <= 0) inciseFlowErosionMap12[index] = value;
    else if (coordinates.z <= 1) inciseFlowErosionMap12[index] = value;
    else if (coordinates.z <= 2) inciseFlowErosionMap34[index] = value;
    else if (coordinates.z <= 3) inciseFlowErosionMap34[index] = value;
    else if (coordinates.z <= 4) inciseFlowErosionMap56[index] = value;
    else inciseFlowErosionMap56[index] = value;
}

float getErosionFlowMapValueAtCoordinates(uint3 coordinates)
{
    uint index = coordinates.x + coordinates.y * mapWidth;

    if (coordinates.z == 1 || coordinates.z == 3 || coordinates.z == 5)
        index += mapWidth * mapWidth;

    if (coordinates.z <= 0) return inciseFlowErosionMap12[index];
    else if (coordinates.z <= 1) return inciseFlowErosionMap12[index];
    else if (coordinates.z <= 2) return inciseFlowErosionMap34[index];
    else if (coordinates.z <= 3) return inciseFlowErosionMap34[index];
    else if (coordinates.z <= 4) return inciseFlowErosionMap56[index];
    else return inciseFlowErosionMap56[index];
}

float getMapValueAtCoordinates(uint3 coordinates)
{
    uint index = coordinates.x + coordinates.y * mapWidth;

    if (coordinates.z == 1 || coordinates.z == 3 || coordinates.z == 5)
        index += mapWidth * mapWidth;

    if (coordinates.z <= 0) return heightMap12[index];
    else if (coordinates.z <= 1) return heightMap12[index];
    else if (coordinates.z <= 2) return heightMap34[index];
    else if (coordinates.z <= 3) return heightMap34[index];
    else if (coordinates.z <= 4) return heightMap56[index];
    else return heightMap56[index];
}

float getFlowMapValueAtCoordinates(uint3 coordinates)
{
    uint index = coordinates.x + coordinates.y * mapWidth;

    if (coordinates.z == 1 || coordinates.z == 3 || coordinates.z == 5)
        index += mapWidth * mapWidth;

    if (coordinates.z <= 0) return flowMap12[index];
    else if (coordinates.z <= 1) return flowMap12[index];
    else if (coordinates.z <= 2) return flowMap34[index];
    else if (coordinates.z <= 3) return flowMap34[index];
    else if (coordinates.z <= 4) return flowMap56[index];
    else return flowMap56[index];
}

float getErodeValueFromFlowCoordinates(uint3 coordinates)
{
    float flowValue = getFlowMapValueAtCoordinates(coordinates);

    //if (flowValue < 1) flowValue = 1;
    //float erodeValue = (log(flowValue) / log(logBase)) * heightFactor;
    float erodeValue = (flowValue / flowMapMaxValue);
    erodeValue = pow(abs(erodeValue), exponent);
    if (erodeValue < minAmount)
        erodeValue = 0;
    else
        erodeValue = (erodeValue - minAmount) / (1 - minAmount);

    //if (erodeValue > flowHeight - waterLevel - MIN_WATER_HEIGHT)
    //    erodeValue = flowHeight - waterLevel - MIN_WATER_HEIGHT;
    //else 
    //if (erodeValue > heightFactor)
    //    erodeValue = heightFactor;

    if (erodeValue < 0)
        erodeValue = 0;

    erodeValue = pow(abs(erodeValue), curveFactor);

    erodeValue *= strength;
    return erodeValue;
}

[numthreads(16, 16, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)mapWidth || id.y >= (uint)mapWidth || id.z >= 6)
        return;

    uint3 cubemap = uint3(id.x, id.y, id.z);

    float height = getMapValueAtCoordinates(id);
    if (height <= waterLevel)
        return;

    //if (exponent <= 1) exponent = 1.1;

    float erodeValue = getErodeValueFromFlowCoordinates(cubemap);
    //float erodeCount = 1;

    if (blur > 0)
    {
        int blurSquareRadius = (int)ceil(blur);

        for (int blurRelativeX = -blurSquareRadius; blurRelativeX <= blurSquareRadius; blurRelativeX++)
        {
            for (int blurRelativeY = -blurSquareRadius; blurRelativeY <= blurSquareRadius; blurRelativeY++)
            {
                if (blurRelativeX == 0 && blurRelativeY == 0)
                    continue;

                float distance = sqrt(blurRelativeX * blurRelativeX + blurRelativeY * blurRelativeY);
                if (distance > blur) continue;

                uint3 erodeCoordinates = getNewCoordinates(id, blurRelativeX, blurRelativeY, mapWidth);

                float distanceRatio = 1 - distance / blur;
                uint3 blurCubemap = uint3(erodeCoordinates.x, erodeCoordinates.y, erodeCoordinates.z);

                float blurErodeValue = getErodeValueFromFlowCoordinates(blurCubemap);
                blurErodeValue *= distanceRatio;

                if (erodeValue < blurErodeValue) erodeValue = blurErodeValue;
            }
        }
    }

    if (erodeValue < 0) erodeValue = 0;
    //if (erodeValue > (height - waterLevel) * 0.99) erodeValue = (height - waterLevel) * 0.99;

    float maxErosionValueAtHeightInfluence1 = (height - waterLevel) * 0.99;
    float erosionValueAtHeightInfluence1 = erodeValue;
    if (erodeValue > maxErosionValueAtHeightInfluence1)
        erosionValueAtHeightInfluence1 = maxErosionValueAtHeightInfluence1;

    erodeValue = (erodeValue * (1 - heightInfluence)) + (erosionValueAtHeightInfluence1 * heightInfluence);

    setErosionFlowMapValueAtCoordinates(cubemap, erodeValue);
}
