// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

int mapWidth;
int mapHeight;
float waterLevel;
float upwardWeight = 10;
float downwardWeight = 1;
float distanceWeight = 10;
float flowAmount = 1;
float maxFlow = 1000;
StructuredBuffer<float> heightMap12;
StructuredBuffer<float> heightMap34;
StructuredBuffer<float> heightMap56;

RWStructuredBuffer<float> distanceMap12;
RWStructuredBuffer<float> distanceMap34;
RWStructuredBuffer<float> distanceMap56;

RWStructuredBuffer<int> connectivityMap12;
RWStructuredBuffer<int> connectivityMap34;
RWStructuredBuffer<int> connectivityMap56;

#include "Assets/Shaders/Cubemap.cginc"

float getMapValueAtCoordinates(int3 coordinates)
{
    int index = coordinates.x + coordinates.y * mapWidth;

    if (coordinates.z == 1 || coordinates.z == 3 || coordinates.z == 5)
        index += mapWidth * mapWidth;

    if (coordinates.z <= 0) return heightMap12[index];
    else if (coordinates.z <= 1) return heightMap12[index];
    else if (coordinates.z <= 2) return heightMap34[index];
    else if (coordinates.z <= 3) return heightMap34[index];
    else if (coordinates.z <= 4) return heightMap56[index];
    else return heightMap56[index];
}

float diagonalHeight(int3 coordinates, float thisHeight)
{
    float diagonalHeight = getMapValueAtCoordinates(coordinates);
    float actualHeight = (diagonalHeight - thisHeight) / 1.41421356 + thisHeight;
    return actualHeight;
}

void checkIsCloser(float neighborDistance, int neighborConnectivity, int neighborIndex, int3 coordinates, float neighborHeight, float myHeight, float distance, inout float lowestConnectedDistance, inout int lowestConnectedIndex)
{
    int myIndex = coordinates.x + coordinates.z * mapWidth + coordinates.y * mapWidth * 6;
    float effectiveWaterLevel = waterLevel * 0.9;

    if (neighborHeight < effectiveWaterLevel)
    {
        lowestConnectedDistance = distance + (effectiveWaterLevel - myHeight) * downwardWeight;
        if (lowestConnectedDistance == 0)
            lowestConnectedDistance = 0.0000001;
        lowestConnectedIndex = neighborIndex;
    }
    else if (neighborDistance != 0 && neighborConnectivity != myIndex)
    {
        float slope = neighborHeight - myHeight; // Downward slope is NEGATIVE. Upward is POSITIVE.
        if (slope > 0)
            slope *= upwardWeight;
        else
            slope *= downwardWeight;

        float currentDistance = neighborDistance;
        float distanceThroughNeighbor = currentDistance + distance + slope;

        if (distanceThroughNeighbor < lowestConnectedDistance || lowestConnectedDistance == 9999999)
        {
            lowestConnectedDistance = distanceThroughNeighbor;
            lowestConnectedIndex = neighborIndex;
            //output[0] = 0;
        }
    }
}

int getConnectivityFrom(int3 coordinates)
{
    int index = coordinates.x + coordinates.y * mapWidth;

    if (coordinates.z == 1 || coordinates.z == 3 || coordinates.z == 5)
        index += mapWidth * mapWidth;

    if (coordinates.z <= 0) return connectivityMap12[index];
    else if (coordinates.z <= 1) return connectivityMap12[index];
    else if (coordinates.z <= 2) return connectivityMap34[index];
    else if (coordinates.z <= 3) return connectivityMap34[index];
    else if (coordinates.z <= 4) return connectivityMap56[index];
    else return connectivityMap56[index];
}

void setConnectivityAt(int3 coordinates, int value)
{
    int index = coordinates.x + coordinates.y * mapWidth;

    if (coordinates.z == 1 || coordinates.z == 3 || coordinates.z == 5)
        index += mapWidth * mapWidth;

    if (coordinates.z <= 0) connectivityMap12[index] = value;
    else if (coordinates.z <= 1) connectivityMap12[index] = value;
    else if (coordinates.z <= 2) connectivityMap34[index] = value;
    else if (coordinates.z <= 3) connectivityMap34[index] = value;
    else if (coordinates.z <= 4) connectivityMap56[index] = value;
    else connectivityMap56[index] = value;
}

float getDistanceFrom(int3 coordinates)
{
    int index = coordinates.x + coordinates.y * mapWidth;

    if (coordinates.z == 1 || coordinates.z == 3 || coordinates.z == 5)
        index += mapWidth * mapWidth;

    if (coordinates.z <= 0) return distanceMap12[index];
    else if (coordinates.z <= 1) return distanceMap12[index];
    else if (coordinates.z <= 2) return distanceMap34[index];
    else if (coordinates.z <= 3) return distanceMap34[index];
    else if (coordinates.z <= 4) return distanceMap56[index];
    else return distanceMap56[index];
}

void setDistanceAt(int3 coordinates, float value)
{
    int index = coordinates.x + coordinates.y * mapWidth;

    if (coordinates.z == 1 || coordinates.z == 3 || coordinates.z == 5)
        index += mapWidth * mapWidth;

    if (coordinates.z <= 0) distanceMap12[index] = value;
    else if (coordinates.z <= 1) distanceMap12[index] = value;
    else if (coordinates.z <= 2) distanceMap34[index] = value;
    else if (coordinates.z <= 3) distanceMap34[index] = value;
    else if (coordinates.z <= 4) distanceMap56[index] = value;
    else distanceMap56[index] = value;
}

[numthreads(8, 8, 6)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)mapWidth || id.y >= (uint)mapWidth || id.z >= 6)
        return;

    int3 cubemap = int3(id.x, id.y, id.z);

    float linearStep = 1 / (float)mapWidth;
    linearStep *= distanceWeight;
    float diagonalStep = linearStep * 1.41421356;

    float height = getMapValueAtCoordinates(cubemap);

    int3 cubemapLeft = getLeftIntCoordinates(cubemap, mapWidth);
    int3 cubemapRight = getRightIntCoordinates(cubemap, mapWidth);
    int3 cubemapTop = getTopIntCoordinates(cubemap, mapWidth);
    int3 cubemapBottom = getBottomIntCoordinates(cubemap, mapWidth);

    int3 cubemapTopLeft = getTopLeftIntCoordinates(cubemap, mapWidth);
    int3 cubemapBottomRight = getBottomRightIntCoordinates(cubemap, mapWidth);
    int3 cubemapTopRight = getTopRightIntCoordinates(cubemap, mapWidth);
    int3 cubemapBottomLeft = getBottomLeftIntCoordinates(cubemap, mapWidth);

    float heightD = getMapValueAtCoordinates(cubemapBottom);
    float heightR = getMapValueAtCoordinates(cubemapRight);
    float heightU = getMapValueAtCoordinates(cubemapTop);
    float heightL = getMapValueAtCoordinates(cubemapLeft);

    float heightDL = diagonalHeight(cubemapBottomLeft, height);
    float heightDR = diagonalHeight(cubemapBottomRight, height);
    float heightUR = diagonalHeight(cubemapTopRight, height);
    float heightUL = diagonalHeight(cubemapTopLeft, height);

    uint index = id.x + id.z * mapWidth + id.y * mapWidth * 6;

    int indexL = cubemapLeft.x + cubemapLeft.z * mapWidth + cubemapLeft.y * mapWidth * 6;
    int indexR = cubemapRight.x + cubemapRight.z * mapWidth + cubemapRight.y * mapWidth * 6;
    int indexT = cubemapTop.x + cubemapTop.z * mapWidth + cubemapTop.y * mapWidth * 6;
    int indexB = cubemapBottom.x + cubemapBottom.z * mapWidth + cubemapBottom.y * mapWidth * 6;
    int indexBL = cubemapBottomLeft.x + cubemapBottomLeft.z * mapWidth + cubemapBottomLeft.y * mapWidth * 6;
    int indexBR = cubemapBottomRight.x + cubemapBottomRight.z * mapWidth + cubemapBottomRight.y * mapWidth * 6;
    int indexTL = cubemapTopLeft.x + cubemapTopLeft.z * mapWidth + cubemapTopLeft.y * mapWidth * 6;
    int indexTR = cubemapTopRight.x + cubemapTopRight.z * mapWidth + cubemapTopRight.y * mapWidth * 6;

    float distance = getDistanceFrom(cubemap);
    float distanceL = getDistanceFrom(cubemapLeft);
    float distanceR = getDistanceFrom(cubemapRight);
    float distanceT = getDistanceFrom(cubemapTop);
    float distanceB = getDistanceFrom(cubemapBottom);
    float distanceBL = getDistanceFrom(cubemapBottomLeft);
    float distanceBR = getDistanceFrom(cubemapBottomRight);
    float distanceTL = getDistanceFrom(cubemapTopLeft);
    float distanceTR = getDistanceFrom(cubemapTopRight);

    float effectiveWaterLevel = waterLevel * 0.9;

    if (height < effectiveWaterLevel)
    {
        return;
    }
    else
    {
        // If any neighbors have a calculated distance, or are below water:
        if (distanceL != 0 || heightL <= waterLevel ||
            distanceR != 0 || heightR <= waterLevel ||
            distanceT != 0 || heightU <= waterLevel ||
            distanceB != 0 || heightD <= waterLevel ||
            distanceBL != 0 || heightDL <= waterLevel ||
            distanceBR != 0 || heightDR <= waterLevel ||
            distanceTL != 0 || heightUL <= waterLevel ||
            distanceTR != 0 || heightUR <= waterLevel)
        {
            int connectivityL = getConnectivityFrom(cubemapLeft);
            int connectivityR = getConnectivityFrom(cubemapRight);
            int connectivityT = getConnectivityFrom(cubemapTop);
            int connectivityB = getConnectivityFrom(cubemapBottom);
            int connectivityBL = getConnectivityFrom(cubemapBottomLeft);
            int connectivityBR = getConnectivityFrom(cubemapBottomRight);
            int connectivityTL = getConnectivityFrom(cubemapTopLeft);
            int connectivityTR = getConnectivityFrom(cubemapTopRight);

            float lowestConnectedDistance = 9999999;
            int lowestConnectedIndex = -1;

            checkIsCloser(distanceTL, connectivityTL, indexTL, cubemap, heightUL, height, diagonalStep, lowestConnectedDistance, lowestConnectedIndex);
            checkIsCloser(distanceT, connectivityT, indexT, cubemap, heightU, height, linearStep, lowestConnectedDistance, lowestConnectedIndex);
            checkIsCloser(distanceTR, connectivityTR, indexTR, cubemap, heightUR, height, diagonalStep, lowestConnectedDistance, lowestConnectedIndex);
            checkIsCloser(distanceL, connectivityL, indexL, cubemap, heightL, height, linearStep, lowestConnectedDistance, lowestConnectedIndex);
            checkIsCloser(distanceR, connectivityR, indexR, cubemap, heightR, height, linearStep, lowestConnectedDistance, lowestConnectedIndex);
            checkIsCloser(distanceBL, connectivityBL, indexBL, cubemap, heightDL, height, diagonalStep, lowestConnectedDistance, lowestConnectedIndex);
            checkIsCloser(distanceB, connectivityB, indexB, cubemap, heightD, height, linearStep, lowestConnectedDistance, lowestConnectedIndex);
            checkIsCloser(distanceBR, connectivityBR, indexBR, cubemap, heightDR, height, diagonalStep, lowestConnectedDistance, lowestConnectedIndex);

            if (lowestConnectedIndex == -1)
                return;

            if (distance == 0 || distance > lowestConnectedDistance)
            {
                setDistanceAt(cubemap, lowestConnectedDistance);
                setConnectivityAt(cubemap, lowestConnectedIndex);
            }
        }
    }
}
