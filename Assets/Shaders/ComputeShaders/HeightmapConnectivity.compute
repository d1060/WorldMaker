// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Connectivity
#pragma kernel FlowMap

int mapWidth;
int mapHeight;
float waterLevel;
float upwardWeight = 10;
float downwardWeight = 1;
float distanceWeight = 10;
float flowAmount = 1;
float maxFlow = 1000;
int maxRiverLength;
StructuredBuffer<float> heightMap;
RWStructuredBuffer<float> distanceMap;
RWStructuredBuffer<uint> connectivityMap;
RWStructuredBuffer<uint> flowMap; // The Flow Map contains a number indicating how much water is flowing into each pixel.

float diagonalHeight(int index, float thisHeight)
{
    float diagonalHeight = heightMap[index];
    float actualHeight = (diagonalHeight - thisHeight) / 1.41421356 + thisHeight;
    return actualHeight;
}

void checkIsCloser(float neighborDistance, int neighborConnectivity, int neighborIndex, int index, float neighborHeight, float myHeight, float distance, inout float lowestConnectedDistance, inout int lowestConnectedIndex)
{
    float effectiveWaterLevel = waterLevel * 0.9;

    if (neighborHeight < effectiveWaterLevel)
    {
        lowestConnectedDistance = distance + (effectiveWaterLevel - myHeight) * downwardWeight;
        if (lowestConnectedDistance == 0)
            lowestConnectedDistance = 0.0000001;
        lowestConnectedIndex = neighborIndex;
    }
    else if (neighborDistance != 0 && neighborConnectivity != index)
    {
        float slope = neighborHeight - myHeight; // Downward slope is NEGATIVE. Upward is POSITIVE.
        if (slope > 0)
            slope *= upwardWeight;
        else
            slope *= downwardWeight;

        float currentDistance = neighborDistance;
        float distanceThroughNeighbor = currentDistance + distance + slope;

        if (distanceThroughNeighbor < lowestConnectedDistance || lowestConnectedDistance == 9999999)
        {
            lowestConnectedDistance = distanceThroughNeighbor;
            lowestConnectedIndex = neighborIndex;
            //output[0] = 0;
        }
    }
}

[numthreads(8, 8, 1)]
void Connectivity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)mapWidth * 4 || id.y >= (uint)mapWidth * 2)
        return;

    int index = id.x + id.y * mapWidth * 4;

    float linearStep = 1 / (float)mapWidth;
    linearStep *= distanceWeight;
    float diagonalStep = linearStep * 1.41421356;

    float height = heightMap[index];

    uint2 uvL = uint2(id.x - 1, id.y);
    uint2 uvR = uint2(id.x + 1, id.y);
    uint2 uvT = uint2(id.x, id.y + 1);
    uint2 uvB = uint2(id.x, id.y - 1);
    uint2 uvTL = uint2(id.x - 1, id.y + 1);
    uint2 uvBR = uint2(id.x + 1, id.y - 1);
    uint2 uvTR = uint2(id.x + 1, id.y + 1);
    uint2 uvBL = uint2(id.x - 1, id.y - 1);

    if (uvL.x < 0)
    {
        uvL.x += mapWidth * 4;
        uvTL.x += mapWidth * 4;
        uvBL.x += mapWidth * 4;
    }

    if (uvR.x >= (uint)mapWidth * 4)
    {
        uvR.x -= mapWidth * 4;
        uvTR.x -= mapWidth * 4;
        uvBR.x -= mapWidth * 4;
    }

    if (uvB.y < 0)
    {
        uvB.y = 0;
        uvBL.y = 0;
        uvBR.y = 0;
    }

    if (uvT.y >= (uint)mapWidth * 2)
    {
        uvT.y = mapWidth * 2 - 1;
        uvTR.y = mapWidth * 2 - 1;
        uvTL.y = mapWidth * 2 - 1;
    }

    int indexL = uvL.x + uvL.y * mapWidth * 4;
    int indexR = uvR.x + uvR.y * mapWidth * 4;
    int indexT = uvT.x + uvT.y * mapWidth * 4;
    int indexB = uvB.x + uvB.y * mapWidth * 4;
    int indexTL = uvTL.x + uvTL.y * mapWidth * 4;
    int indexBR = uvBR.x + uvBR.y * mapWidth * 4;
    int indexTR = uvTR.x + uvTR.y * mapWidth * 4;
    int indexBL = uvBL.x + uvBL.y * mapWidth * 4;

    float heightD = heightMap[indexB];
    float heightR = heightMap[indexR];
    float heightU = heightMap[indexT];
    float heightL = heightMap[indexL];

    float heightDL = diagonalHeight(indexBL, height);
    float heightDR = diagonalHeight(indexBR, height);
    float heightUR = diagonalHeight(indexTR, height);
    float heightUL = diagonalHeight(indexTL, height);

    float distance = distanceMap[index];
    float distanceL = distanceMap[indexL];
    float distanceR = distanceMap[indexR];
    float distanceT = distanceMap[indexT];
    float distanceB = distanceMap[indexB];
    float distanceBL = distanceMap[indexBL];
    float distanceBR = distanceMap[indexBR];
    float distanceTL = distanceMap[indexTL];
    float distanceTR = distanceMap[indexTR];

    float effectiveWaterLevel = waterLevel * 0.9;

    if (height < effectiveWaterLevel)
    {
        return;
    }
    else
    {
        // If any neighbors have a calculated distance, or are below water:
        if (distanceL != 0 || heightL <= waterLevel ||
            distanceR != 0 || heightR <= waterLevel ||
            distanceT != 0 || heightU <= waterLevel ||
            distanceB != 0 || heightD <= waterLevel ||
            distanceBL != 0 || heightDL <= waterLevel ||
            distanceBR != 0 || heightDR <= waterLevel ||
            distanceTL != 0 || heightUL <= waterLevel ||
            distanceTR != 0 || heightUR <= waterLevel)
        {
            int connectivityL = connectivityMap[indexL];
            int connectivityR = connectivityMap[indexR];
            int connectivityT = connectivityMap[indexT];
            int connectivityB = connectivityMap[indexB];
            int connectivityBL = connectivityMap[indexBL];
            int connectivityBR = connectivityMap[indexBR];
            int connectivityTL = connectivityMap[indexTL];
            int connectivityTR = connectivityMap[indexTR];

            float lowestConnectedDistance = 9999999;
            int lowestConnectedIndex = -1;

            checkIsCloser(distanceTL, connectivityTL, indexTL, index, heightUL, height, diagonalStep, lowestConnectedDistance, lowestConnectedIndex);
            checkIsCloser(distanceT, connectivityT, indexT, index, heightU, height, linearStep, lowestConnectedDistance, lowestConnectedIndex);
            checkIsCloser(distanceTR, connectivityTR, indexTR, index, heightUR, height, diagonalStep, lowestConnectedDistance, lowestConnectedIndex);
            checkIsCloser(distanceL, connectivityL, indexL, index, heightL, height, linearStep, lowestConnectedDistance, lowestConnectedIndex);
            checkIsCloser(distanceR, connectivityR, indexR, index, heightR, height, linearStep, lowestConnectedDistance, lowestConnectedIndex);
            checkIsCloser(distanceBL, connectivityBL, indexBL, index, heightDL, height, diagonalStep, lowestConnectedDistance, lowestConnectedIndex);
            checkIsCloser(distanceB, connectivityB, indexB, index, heightD, height, linearStep, lowestConnectedDistance, lowestConnectedIndex);
            checkIsCloser(distanceBR, connectivityBR, indexBR, index, heightDR, height, diagonalStep, lowestConnectedDistance, lowestConnectedIndex);

            if (lowestConnectedIndex == -1)
                return;

            if (distance == 0 || distance > lowestConnectedDistance)
            {
                distanceMap[index] = lowestConnectedDistance;
                connectivityMap[index] = lowestConnectedIndex;
            }
        }
    }
}

[numthreads(8, 8, 1)]
void FlowMap(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)mapWidth * 4 || id.y >= (uint)mapWidth * 2)
        return;

    int index = id.x + id.y * mapWidth * 4;
    int connectivity = index;
    float addFlowAmount = flowAmount > 0.000001 ? flowAmount : 0.000001;

    for (int i = 0; i < maxRiverLength; i++)
    {
        int newIndex = connectivityMap[connectivity];
        if (newIndex == 0)
            return;

        InterlockedAdd(flowMap[newIndex], addFlowAmount);
        connectivity = newIndex;
    }
}
