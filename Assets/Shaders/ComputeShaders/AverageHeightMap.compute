// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

int mapWidth;
float blur = 0;
int blurStep;

RWStructuredBuffer<float> sourceHeightMap;
RWStructuredBuffer<float> targetHeightMap;

float diagonalHeight(int index, float thisHeight)
{
    float diagonalHeight = sourceHeightMap[index];
    float actualHeight = (diagonalHeight - thisHeight) / 1.41421356 + thisHeight;
    return actualHeight;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)mapWidth * 4 || id.y >= (uint)mapWidth * 2)
        return;

    int index = id.x + id.y * 4 * mapWidth;

    uint2 uvL = uint2(id.x - 1, id.y);
    uint2 uvR = uint2(id.x + 1, id.y);
    uint2 uvT = uint2(id.x, id.y + 1);
    uint2 uvB = uint2(id.x, id.y - 1);
    uint2 uvTL = uint2(id.x - 1, id.y + 1);
    uint2 uvBR = uint2(id.x + 1, id.y - 1);
    uint2 uvTR = uint2(id.x + 1, id.y + 1);
    uint2 uvBL = uint2(id.x - 1, id.y - 1);

    if (uvL.x < 0)
    {
        uvL.x += mapWidth * 4;
        uvTL.x += mapWidth * 4;
        uvBL.x += mapWidth * 4;
    }

    if (uvR.x >= (uint)mapWidth * 4)
    {
        uvR.x -= mapWidth * 4;
        uvTR.x -= mapWidth * 4;
        uvBR.x -= mapWidth * 4;
    }

    if (uvB.y < 0)
    {
        uvB.y = 0;
        uvBL.y = 0;
        uvBR.y = 0;
    }

    if (uvT.y >= (uint)mapWidth * 2)
    {
        uvT.y = mapWidth * 2 - 1;
        uvTR.y = mapWidth * 2 - 1;
        uvTL.y = mapWidth * 2 - 1;
    }

    int indexL = uvL.x + uvL.y * mapWidth * 4;
    int indexR = uvR.x + uvR.y * mapWidth * 4;
    int indexT = uvT.x + uvT.y * mapWidth * 4;
    int indexB = uvB.x + uvB.y * mapWidth * 4;
    int indexTL = uvTL.x + uvTL.y * mapWidth * 4;
    int indexBR = uvBR.x + uvBR.y * mapWidth * 4;
    int indexTR = uvTR.x + uvTR.y * mapWidth * 4;
    int indexBL = uvBL.x + uvBL.y * mapWidth * 4;


    float height = sourceHeightMap[index];
    float heightD = sourceHeightMap[indexB];
    float heightR = sourceHeightMap[indexR];
    float heightU = sourceHeightMap[indexT];
    float heightL = sourceHeightMap[indexL];
    float heightDL = diagonalHeight(indexBL, height);
    float heightDR = diagonalHeight(indexBR, height);
    float heightUR = diagonalHeight(indexTR, height);
    float heightUL = diagonalHeight(indexTL, height);

    float squaredBlurStep = pow((2 * blurStep) + 1, 2);
    float squaredPrevBlurStep = pow((2 * (blurStep - 1)) + 1, 2);
    float minBlurWeight = 1.0 / squaredBlurStep;
    float maxBlurWeight = 1.0 / squaredPrevBlurStep;

    float blurWeight = 1 - (blur - floor(blur));

    blurWeight = blurWeight * (maxBlurWeight - minBlurWeight) + minBlurWeight;
    float othersBlurWeight = 1 - blurWeight;

    float numHeights = blurWeight;
    float totalHeight = height * blurWeight;

    float othersNumHeights = 0;
    float othersTotalHeight = 0;

    othersTotalHeight += heightUL + heightU + heightUR;
    othersNumHeights += 3;

    othersTotalHeight += heightL + heightR;
    othersNumHeights += 2;

    othersTotalHeight += heightDL + heightD + heightDR;
    othersNumHeights += 3;

    othersNumHeights *= othersBlurWeight;
    othersTotalHeight *= othersBlurWeight;

    totalHeight += othersTotalHeight;
    numHeights += othersNumHeights;

    float finalHeight = totalHeight / numHeights;

    targetHeightMap[index] = finalHeight;
}
