// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

int mapWidth;
int mapHeight;
int cubemapDimension;
int subdivision;
int subDivisionX;
int subDivisionY;
int faceId;
float offsetPixels;
Texture2D<float4> base;
SamplerState samplerbase;
RWTexture2D<float4> Result;

#define PI 3.14159274
#define Rad2Deg 57.29578

#include "Assets/Shaders/Cubemap.cginc"

//float4 bilinear(float2 coord)
//{
//    int leftX = (int)floor(coord.x);
//    int rightX = (int)ceil(coord.x);
//    int bottomY = (int)floor(coord.y);
//    int topY = (int)ceil(coord.y);
//
//    float deltaX = coord.x - leftX;
//    float deltaY = coord.y - bottomY;
//
//    if (rightX >= mapWidth) rightX -= mapWidth;
//    if (rightX < 0) rightX += mapWidth;
//    if (leftX >= mapWidth) leftX -= mapWidth;
//    if (leftX < 0) leftX += mapWidth;
//    if (topY >= mapHeight) topY = mapHeight - 1;
//    if (topY < 0) topY = 0;
//    if (bottomY >= mapHeight) bottomY = mapHeight - 1;
//    if (bottomY < 0) bottomY = 0;
//
//    int2 indexBL = int2(leftX, bottomY);
//    int2 indexBR = int2(rightX, bottomY);
//    int2 indexTR = int2(rightX, topY);
//    int2 indexTL = int2(leftX, topY);
//
//    float4 valueBL = base[indexBL];
//    float4 valueBR = base[indexBR];
//    float4 valueTL = base[indexTL];
//    float4 valueTR = base[indexTR];
//
//    float4 valueXdelta0 = (valueBR - valueBL) * deltaX + valueBL;
//    float4 valueXdelta1 = (valueTR - valueTL) * deltaX + valueTL;
//
//    float4 value = (valueXdelta1 - valueXdelta0) * deltaY + valueXdelta0;
//    return value;
//}

[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)cubemapDimension || id.y >= (uint)cubemapDimension)
        return;

    float2 cubeMapCoordinate = float2(id.x / (float)cubemapDimension, id.y / (float)cubemapDimension); // From 0 to 1.
    float divisionPower = pow(2, subdivision);
    float pixelsPerDivision = cubemapDimension / divisionPower;

    float2 faceCenter = float2(0, 0);
    if (subdivision > 0)
    {
        float halfFaceShift = (1 / divisionPower) / 2;
        if (subDivisionX >= 0 && subDivisionX < divisionPower)
        {
            float minX = pixelsPerDivision * (float)subDivisionX / (float)cubemapDimension;
            cubeMapCoordinate.x = minX + (cubeMapCoordinate.x * pixelsPerDivision) / cubemapDimension;
            faceCenter.x = minX + halfFaceShift;
        }
        if (subDivisionY >= 0 && subDivisionY < divisionPower)
        {
            float minY = pixelsPerDivision * (divisionPower - (float)subDivisionY - 1.0) / (float)cubemapDimension;
            cubeMapCoordinate.y = minY + (cubeMapCoordinate.y * pixelsPerDivision) / cubemapDimension;
            faceCenter.y = minY + halfFaceShift;
        }
    }
    float3 cartesian = cubemapToCartesian(cubeMapCoordinate, faceId);
    float2 polar = cartesianToPolarRatio(cartesian);

    float3 faceCenterCartesian = cubemapToCartesian(faceCenter, faceId);
    float2 faceCenterPolar = cartesianToPolarRatio(faceCenterCartesian);

    float offsetRatio = 1 + (offsetPixels / ((float)cubemapDimension));
    // Shifts based on the pixel offsets
    if (subdivision == 0 && offsetPixels > 0)
    {
        if (faceId == 4) // Top
        {
            float invY = 1 - polar.y;
            invY *= offsetRatio;
            polar.y = 1 - invY;
        }
        else if (faceId == 5) // Bottom
        {
            polar.y *= offsetRatio;
        }
        else if (faceId == 0) // Left face is split in half at the start and the end
        {
            float y = polar.y - 0.5;
            y *= offsetRatio;
            y += 0.5;

            float x = 0;
            if (polar.x < 0.5)
            {
                x = polar.x * offsetRatio;
            }
            else
            {
                x = polar.x - 1;
                x *= offsetRatio;
                x += 1;
            }
            polar = float2(x, y);
        }
        else
        {
            float2 faceCenter = float2(0.25, 0.5);
            if (faceId == 2)
            {
                faceCenter = float2(0.5, 0.5);
            }
            else if (faceId == 3)
            {
                faceCenter = float2(0.75, 0.5);
            }

            float2 relativePolar = polar - faceCenter;
            relativePolar *= offsetRatio;
            polar = relativePolar + faceCenter;
        }
    }
    else if (subdivision > 0 && offsetPixels > 0)
    {
        float2 relativePolar = polar - faceCenterPolar;
        relativePolar *= offsetRatio;
        polar = relativePolar + faceCenterPolar;
    }

    // Shifts for the center meridian
    //polar.x -= 0.125;
    if (polar.x < 0)  polar.x += 1;
    if (polar.x >= 1) polar.x -= 1;

    //polar.x *= mapWidth;
    //polar.y *= mapHeight;

    float4 color = base.SampleLevel(samplerbase, polar, 0); // bilinear(polar);

    Result[id.xy] = color;
}
