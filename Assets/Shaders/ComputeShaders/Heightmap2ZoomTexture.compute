// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
int mapWidth;
int mapHeight;
int worldTextureWidth;
float centerU;
float centerV;
float boundaryU;
float boundaryV;

float erosionNoiseMerge;

float _MinimumHeight;
float _MaximumHeight;

float _Seed;
int _Octaves;
float _Lacunarity;
float _Persistence;
float _Multiplier;
float _xOffset;
float _yOffset;
float _zOffset;
int _RidgedNoise;
float _DomainWarping;
float _HeightExponent;
float _LayerStrength;

float _xOffset2;
float _yOffset2;
float _zOffset2;
float _Seed2;
float _Multiplier2;
int _Octaves2;
float _Lacunarity2;
float _Persistence2;
int _RidgedNoise2;
float _HeightExponent2;
float _LayerStrength2;
float _DomainWarping2;

StructuredBuffer<float> heightMap;
StructuredBuffer<float> flowErosionMap;

RWTexture2D<float4> result;

#include "Assets/Shaders/Simplex.cginc"

float Interpolate(float valueDL, float valueDR, float valueUL, float valueUR, float Xrate, float Yrate)
{
    float valueR = valueDR * (1 - Yrate) + valueUR * Yrate;
    float valueL = valueDL * (1 - Yrate) + valueUL * Yrate;

    float value = valueL * (1 - Xrate) + valueR * Xrate;
    return value;
}

float erodeHeight(float2 worldTextureUV, float height)
{
    int2 worldTextureUV_DR = int2(worldTextureUV.x + 1, worldTextureUV.y);
    if (worldTextureUV_DR.x >= worldTextureWidth * 4) worldTextureUV_DR.x -= worldTextureWidth * 4;

    int2 worldTextureUV_UL = int2(worldTextureUV.x, worldTextureUV.y + 1);
    if (worldTextureUV_UL.y >= worldTextureWidth * 2) worldTextureUV_UL.y = worldTextureWidth * 4 - worldTextureUV_UL.y;

    int2 worldTextureUV_UR = int2(worldTextureUV.x + 1, worldTextureUV.y + 1);
    if (worldTextureUV_UR.x >= worldTextureWidth * 4) worldTextureUV_UR.x -= worldTextureWidth * 4;
    if (worldTextureUV_UR.y >= worldTextureWidth * 2) worldTextureUV_UR.y = worldTextureWidth * 4 - worldTextureUV_UR.y;

    int index = (int)worldTextureUV.x + (int)worldTextureUV.y * worldTextureWidth * 4;
    int indexR = (int)worldTextureUV_DR.x + (int)worldTextureUV_DR.y * worldTextureWidth * 4;
    int indexU = (int)worldTextureUV_UL.x + (int)worldTextureUV_UL.y * worldTextureWidth * 4;
    int indexUR = (int)worldTextureUV_UR.x + (int)worldTextureUV_UR.y * worldTextureWidth * 4;

    float erodedHeight = flowErosionMap[index];
    float erodedHeightR = flowErosionMap[indexR];
    float erodedHeightU = flowErosionMap[indexU];
    float erodedHeightUR = flowErosionMap[indexUR];

    float Xrate = worldTextureUV.x - (int)worldTextureUV.x;
    float Yrate = worldTextureUV.y - (int)worldTextureUV.y;

    float erosion = Interpolate(erodedHeight, erodedHeightR, erodedHeightU, erodedHeightUR, Xrate, Yrate);

    float mergedHeight = height - erosion * erosionNoiseMerge;

    if (mergedHeight <= 0)
        return 0;

    return mergedHeight;
}

#define PI 3.14159265359

float3 RotateAboutAxis(float3 In, float3 Axis, float Rotation)
{
    float s = sin(Rotation);
    float c = cos(Rotation);
    float one_minus_c = 1.0 - c;

    Axis = normalize(Axis);
    float3x3 rot_mat =
    { one_minus_c * Axis.x * Axis.x + c, one_minus_c * Axis.x * Axis.y - Axis.z * s, one_minus_c * Axis.z * Axis.x + Axis.y * s,
        one_minus_c * Axis.x * Axis.y + Axis.z * s, one_minus_c * Axis.y * Axis.y + c, one_minus_c * Axis.y * Axis.z - Axis.x * s,
        one_minus_c * Axis.z * Axis.x - Axis.y * s, one_minus_c * Axis.y * Axis.z + Axis.x * s, one_minus_c * Axis.z * Axis.z + c
    };
    return mul(rot_mat, In);
}

[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float3 offset = float3(_xOffset, _yOffset, _zOffset);
    float3 offset2 = float3(_xOffset2, _yOffset2, _zOffset2);

    // Rotate Vector. Zoom Logic
    float2 originalUV = float2((float)id.x / ((float)mapWidth), (float)id.y / ((float)mapHeight));

    float Ustep = (0.5 - originalUV.x) * boundaryU;
    float Vstep = (originalUV.y - 0.5) * boundaryV;
    float Uangle = Ustep * 2 * PI;
    float Vangle = Vstep * PI;

    float3 position = UvToSphere(float2(centerU, centerV));

    float3 rightVector = cross(float3(0, 1, 0), position);
    float3 upVector = cross(position, rightVector);

    float3 rotationX = RotateAboutAxis(position, upVector, Uangle);

    rightVector = cross(rotationX, upVector);

    float3 rotated = RotateAboutAxis(rotationX, rightVector, Vangle);

    // Calculate Heights
    float2 worldUV = SphereToUv(rotated);

    float2 worldTextureUV = float2(worldUV.x * worldTextureWidth * 4, worldUV.y * worldTextureWidth * 2);

    float height = sphereHeight(worldUV, offset, _Seed, _Multiplier, _Octaves, _Lacunarity, _Persistence, _RidgedNoise, _HeightExponent, _LayerStrength, _DomainWarping, offset2, _Seed2, _Multiplier2, _Octaves2, _Lacunarity2, _Persistence2, _RidgedNoise2, _HeightExponent2, _LayerStrength2, _DomainWarping2, _MinimumHeight, _MaximumHeight);

    height = erodeHeight(worldTextureUV, height);

    result[id.xy] = float4(height, height, height, 1);
}
